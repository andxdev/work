import numpy as np
import pandas as pd

def monthly_from_daily(dates, fx_levels, how="eom"):
    s = pd.Series(pd.to_numeric(fx_levels, errors="coerce"),
                  index=pd.to_datetime(dates)).sort_index()
    if how == "eom":
        return s.resample("M").last()
    elif how == "avg":
        return s.resample("M").mean()
    else:
        raise ValueError("how must be 'eom' or 'avg'.")

def historical_max_curve(monthly_fx: pd.Series,
                         H: int = 180,
                         is_usdjpy: bool = True,
                         use_log: bool = False) -> pd.Series:
    """
    For each horizon h=1..H, compute the maximum h-month JPY depreciation vs USD (in %).
    Pass USDJPY (JPY per USD) with is_usdjpy=True.
    If you have JPYUSD, set is_usdjpy=False (weâ€™ll invert to USDJPY).
    """
    # clean & orient
    s = pd.to_numeric(monthly_fx, errors="coerce").astype(float).dropna().sort_index()
    if not is_usdjpy:
        s = 1.0 / s  # convert JPYUSD -> USDJPY

    # cap H to sample size - 1
    H = int(min(H, max(len(s) - 1, 0)))

    out = []
    for h in range(1, H + 1):
        if use_log:
            dep_h = 100.0 * (np.log(s.shift(-h)) - np.log(s))
        else:
            dep_h = 100.0 * (s.shift(-h) / s - 1.0)
        dep_h = dep_h.iloc[:-h].dropna()   # drop the last h NaNs and any gaps
        out.append(dep_h.max() if not dep_h.empty else np.nan)

    idx = pd.RangeIndex(1, H + 1, name="months")
    return pd.Series(out, index=idx, name="HistoricalMax(%)")
